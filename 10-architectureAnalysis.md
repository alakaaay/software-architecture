# 10.	Анализ и описание архитектурных опций 

## Клиентское приложение 
| Опция | Преимущества | Недостатки | Что выбираем |
|-------|--------------|------------|---------------|
| Нативные iOS/Android (Swift/Kotlin) | Максимальная производительность и отзывчивость; полный доступ к сенсорам и API (GPS, BT, HealthKit, Google Fit); лучший UX | Два отдельных стека разработки, выше стоимость поддержки |+ |
| Кроссплатформа (Flutter/React Native) | Быстрая разработка одной кодовой базы; меньше затраты на поддержку | Ограниченный доступ к нативным сенсорам, возможны проблемы с производительностью и интеграцией HealthKit/Google Fit |  |
| PWA / веб-приложение | Дешевле в разработке; не требует установки; удобно для шеринга контента | Нет доступа к сенсорам и оффлайн-работе; слабее пользовательский опыт |  |

**Обоснование:** для спорта критичны сенсоры, работа в фоне и UX → только натив. Flutter можно применять для пилотов и быстрых экспериментов. PWA — вспомогательный канал.  
**Выбор:** Swift (iOS) и Kotlin (Android) как основной стек, Flutter для быстрых MVP.

## Архитектурный стиль
| Опция | Преимущества | Недостатки | Что выбираем |
|-------|--------------|------------|---------------|
| Монолит | Простая разработка и деплой, меньше накладных расходов | Трудно масштабировать, сложно вносить изменения при росте |  |
| Модульный монолит | Централизованное управление, чёткие домены внутри одного кода | Ограниченное масштабирование, со временем растёт сложность | |
| Микросервисы | Независимое масштабирование, быстрая эволюция, гибкая команда | Сложнее DevOps, выше требования к инфраструктуре |+ |

### Обоснование
**Обоснование:** стартовать проще на модульном монолите (этап MVP), но стратегия роста — микросервисы с event-driven взаимодействием.  
**Выбор:** модульный монолит → эволюция в микросервисы (Java/Spring Boot, Go, Node.js в зависимости от команды).


## Хранение данных — реляционные и нереляционные БД
| Опция | Преимущества | Недостатки | Что выбираем |
|-------|--------------|------------|---------------|
| Реляционные (PostgreSQL, MySQL) | ACID-транзакции, зрелая экосистема, удобны для связных данных (профили, соц.граф) | Сложнее масштабировать горизонтально, не оптимальны для больших объёмов телеметрии | +|
| Нереляционные (MongoDB, Cassandra, DynamoDB) | Гибкая схема, легко масштабируются, хорошо для событийных/временных рядов | Нет строгих ACID, сложнее реализовать сложные связи |  |
### Обоснование
**Обоснование:** профили и соц.связи требуют транзакций → PostgreSQL. Телеметрия и временные ряды → ClickHouse. Логи/ивенты → Elasticsearch.  
**Выбор:** Polyglot-подход: PostgreSQL + ClickHouse + Redis + S3.


## API слой 

| Опция | Преимущества | Недостатки | Что выбираем |
|-------|--------------|------------|---------------|
| Только REST API | Простота, широкая поддержка, легко интегрировать | Избыточные запросы у мобильных клиентов, нет гибкой агрегации | |
| Только GraphQL | Гибкость, один запрос = нужные данные, удобен для мобильных | Более сложная реализация, кэширование и безопасность сложнее | |
| API Gateway + BFF | Централизованный контроль (auth, rate-limit), адаптация под клиента, унификация | Более сложная инфраструктура | + |
### Обоснование
**Обоснование:** REST — основа, GraphQL — выборочно (лента, статистика). API Gateway + BFF решают проблемы безопасности и оптимизации для клиентов.  
**Выбор:** Kong/KrakenD (API Gateway) + Node.js/TypeScript (BFF).
