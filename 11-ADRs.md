# 11. Список ADR

## ADR-001: Выбор архитектурного стиля
- **Решение:** использовать микросервисную архитектуру с эволюцией от модульного монолита.  
- **Статус:** принято.  
- **Альтернативы:** чистый монолит, микросервисы с самого старта.  
- **Обоснование:** модульный монолит проще для MVP, но рост и глобальный масштаб требуют независимого масштабирования сервисов.  

---

## ADR-002: Клиентские приложения
- **Решение:** нативные приложения для iOS (Swift) и Android (Kotlin) + PWA для промо и лёгкого доступа. Flutter — для экспериментов.  
- **Статус:** принято.  
- **Альтернативы:** полностью кроссплатформенное приложение.  
- **Обоснование:** критичны сенсоры и UX → только натив; Flutter подходит для MVP и быстрых экспериментов.  

---

## ADR-003: API слой
- **Решение:** REST API как основной подход, GraphQL выборочно (лента, статистика), API Gateway + BFF.  
- **Статус:** принято.  
- **Альтернативы:** только REST, только GraphQL.  
- **Обоснование:** REST даёт простоту и совместимость; GraphQL улучшает эффективность для мобильных клиентов; API Gateway обеспечивает безопасность и адаптацию.  

---

## ADR-004: Хранение данных
- **Решение:** polyglot persistence: PostgreSQL (профили, транзакции), ClickHouse (телеметрия), Redis (кэш, лидборды), S3/MinIO (медиа).  
- **Статус:** принято.  
- **Альтернативы:** одна универсальная СУБД (например, только PostgreSQL или только MongoDB).  
- **Обоснование:** разные типы данных → разные оптимальные движки.  

---

## ADR-005: Интеграции
- **Решение:** использовать событийную шину (Kafka) для асинхронного взаимодействия между сервисами; синхронные REST-запросы для CRUD-операций.  
- **Статус:** принято.  
- **Альтернативы:** только синхронные REST API.  
- **Обоснование:** событийная модель лучше для масштабируемости и обработки большого объёма телеметрии.  

---

## ADR-006: Аутентификация и авторизация
- **Решение:** централизованное управление через Keycloak (OAuth2, OpenID Connect).  
- **Статус:** принято.  
- **Альтернативы:** кастомная реализация.  
- **Обоснование:** Keycloak — зрелое решение, даёт гибкость и соответствие стандартам безопасности (GDPR, HIPAA).  

---

## ADR-007: Облачная инфраструктура
- **Решение:** multi-cloud стратегия (AWS, GCP, Azure по регионам), Kubernetes как стандарт оркестрации.  
- **Статус:** принято.  
- **Альтернативы:** использование одного облачного провайдера.  
- **Обоснование:** компания уже использует разных провайдеров; multi-cloud снижает риски вендор-локина и повышает отказоустойчивость.  

---

## ADR-008: Мониторинг и наблюдаемость
- **Решение:** Prometheus + Grafana для метрик, ELK для логов, Jaeger для трейсинга.  
- **Статус:** принято.  
- **Альтернативы:** облачные решения мониторинга (Datadog, NewRelic).  
- **Обоснование:** open-source инструменты дают гибкость и независимость, можно расширять при переходе в разные облака.

## ADR-009: Технологический стек бекенда
- **Решение:** использовать Java (Spring Boot) и Kotlin (Ktor) как основные языки и фреймворки для микросервисов.  
- **Статус:** принято.  
- **Альтернативы:** Node.js (NestJS), Go, .NET.  
- **Обоснование:**  
  - Java/Spring Boot — зрелая экосистема, большое комьюнити, удобна для корпоративных сервисов (авторизация, профили, транзакции).  
  - Kotlin/Ktor — современный язык, подходит для сервисов, где важна лёгкость и высокая скорость (соц.функции, уведомления).  
  - Go рассматривался как альтернатива для high-load сервисов (стриминг телеметрии), но команда сильнее в JVM.  
  - Node.js хорош для BFF-слоя, но не выбран как основной стек, чтобы избежать фрагментации технологий.
 
## ADR-010: Очереди и асинхронные события
- **Решение:** Kafka как стандартная событийная шина.  
- **Статус:** принято.  
- **Альтернативы:** RabbitMQ, AWS SQS.  
- **Обоснование:** Kafka оптимальна для high-throughput задач (телеметрия тренировок, массовые уведомления, события соц.сети). RabbitMQ проще в администрировании, но хуже масштабируется.  

